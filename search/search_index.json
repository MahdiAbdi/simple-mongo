{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"simple-mongo"},{"location":"/index.html#simple-mongo","text":"A library for easy usage of the mongo-scala-driver.\nFeatures:\nEasy Database Config with provider and MongoConfig Implement the DAO Pattern for simple MongoDB usage (MongoDAO) GridFS support (GridFSDAO) Reactive Streams support (Usage in simple-mongo) Enhanced BSON conversion support (Bson) Relationships","title":"simple-mongo"},{"location":"/index.html#additional-documentation","text":"mongo-scala-driver MongoDB","title":"Additional Documentation"},{"location":"/index.html#dependency-setup","text":"Support Scala 2.12 and Scala 2.13.\nsbt libraryDependencies += \"com.sfxcode.nosql\" %% \"simple-mongo\" % \"2.0.1\" Maven <dependency>\n  <groupId>com.sfxcode.nosql</groupId>\n  <artifactId>simple-mongo_2.13</artifactId>\n  <version>2.0.1</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.sfxcode.nosql', name: 'simple-mongo_2.13', version: '2.0.1'\n}","title":"Dependency Setup"},{"location":"/index.html#licence","text":"Apache 2","title":"Licence"},{"location":"/index.html#example-model","text":"Create custom model classes.\ncase class Student(_id: Long, name: String, scores: List[Score], image: Option[ObjectId])\n\ncase class Score(score: Double, `type`: String)\n\ncase class Grade(_id: ObjectId, student_id: Long, class_id: Long, scores: List[Score])","title":"Example: Model"},{"location":"/index.html#example-database","text":"package com.sfxcode.nosql.mongo.test\n\nimport com.sfxcode.nosql.mongo.database.DatabaseProvider\nimport com.sfxcode.nosql.mongo.model._\nimport com.sfxcode.nosql.mongo.server.LocalServer\nimport com.sfxcode.nosql.mongo.{GridFSDAO, MongoDAO}\nimport org.bson.codecs.configuration.CodecRegistries.{fromProviders, fromRegistries}\nimport org.bson.codecs.configuration.CodecRegistry\nimport org.mongodb.scala.bson.codecs.Macros._\n\nobject UniversityDatabase {\n  // create local test server (mongo-java-server)\n  val LocalTestServer = LocalServer.fromPath(\"unit.test.local.mongo.server\")\n\n  // create codecs for custom classes\n  private val universityRegistry: CodecRegistry = fromProviders(classOf[Student], classOf[Score], classOf[Grade])\n\n  private val registry: CodecRegistry = fromRegistries(universityRegistry)\n\n  // create provider\n  val provider: DatabaseProvider = DatabaseProvider.fromPath(configPath = \"unit.test.mongo.local\", registry = registry)\n\n  // setup DAO objects with mongo collection names\n\n  object StudentDAO extends MongoDAO[Student](provider, \"university-students\")\n\n  object GradeDAO extends MongoDAO[Book](provider, \"university-grades\")\n\n  object SudentImagesDAO extends GridFSDAO(provider, \"university-images\")\n\n}","title":"Example: Database"},{"location":"/database/index.html","text":"","title":"Database"},{"location":"/database/index.html#database","text":"Database Connection can be done using MongConfig.\nDatabaseProvider Instance contains setup for registries and databases.\nDatabase provider will ues database by name from MongoConfig by default. Multiple databases access is supported on the same client is supported. For different MongoDBs you have to use different providers.","title":"Database"},{"location":"/database/index.html#databaseprovider","text":"DatabaseProvider is the central repository for MongoClient, registries, databases and collections.\nEvery index / index Instance needs this class.\nval provider: DatabaseProvider = DatabaseProvider(MongoConfig.fromPath())\n\nval database: MongoDatabase = provider.database()\n\n// Infos for all collections in the default database\nval collectionInfos: List[CollectionInfo] = provider.collectionInfos()","title":"DatabaseProvider"},{"location":"/database/config.html","text":"","title":"MongConfig"},{"location":"/database/config.html#mongconfig","text":"Database Configuration can be done using MongConfig.","title":"MongConfig"},{"location":"/database/config.html#create-mongoconfig-with-application-conf","text":"","title":"Create MongoConfig with application.conf"},{"location":"/database/config.html#with-default-path","text":"Default path in application.conf: mongo\nmongo {\n  database = \"university\"\n  host = \"localhost\"\n  port = 270007\n  applicationName = \"mongo.db.sample\"\n  userName = \"standard_user\"\n  password = \"change_me\"\n  pool {\n    minSize = 5\n    maxSize = 100\n  }\n}\nScala Code Snippet\nval config: MongoConfig = MongoConfig.fromPath()","title":"With default path"},{"location":"/database/config.html#with-custom-path","text":"mongo.db.test {\n  database = \"unit_test\"\n  host = \"localhost\"\n  port = 270007\n  applicationName = \"mongo.db.unit.test\"\n  userName = \"unit_test\"\n  password = \"change_me\"\n}\nScala Code Snippet\nval customConfig: MongoConfig = MongoConfig.fromPath(\"mongo.db.prod\")","title":"With custom path"},{"location":"/database/config.html#create-mongoconfig-with-custom-clientsettings","text":"val config = MongoConfig(\"my_database\", customClientSettings = Some(myClientSettings))","title":"Create MongoConfig with custom ClientSettings"},{"location":"/database/config.html#mongoconfig-options","text":"MongoConfig holds all the neded Data for creating a MongoClient.\nIt is used for DatabaseProvider creation.\nKey Description Default value database default database to use host 127.0.0.1 port 27017 applicationName simple-mongo-app userName used for Authentification password used for Authentification poolOptions MongoPoolOptions() compressors List: zlib, snappy, zstd List() customClientSettings None","title":"MongoConfig Options"},{"location":"/database/config.html#mongoconfig-pool-options","text":"Key Default value maxConnectionIdleTime 60 maxSize 50 minSize 0 DefaultMaintenanceInitialDelay 0","title":"MongoConfig Pool Options"},{"location":"/database/config.html#multiple-databases-access","text":"","title":"Multiple databases access"},{"location":"/database/provider.html","text":"","title":"DatabaseProvider"},{"location":"/database/provider.html#databaseprovider","text":"DatabaseProvider is the central repository for MongoClient, registries, databases and collections.\nDatabaseProvider gives access to\nMongoClient MongoDatabase MongoCollection","title":"DatabaseProvider"},{"location":"/database/provider.html#registries","text":"ScalaDriverDocs Additional Info for Registries","title":"Registries"},{"location":"/database/provider.html#create-case-classes","text":"case class Student(_id: Long, name: String, scores: List[Score])\n\ncase class Score(score: Double, `type`: String)\n\ncase class Grade(_id: ObjectId, student_id: Long, class_id: Long, scores: List[Score])","title":"Create Case Classes"},{"location":"/database/provider.html#create-registry","text":"val registry: CodecRegistry =\n  fromProviders(classOf[Student], classOf[Score], classOf[Grade])\n\nval providerWithRegistry: DatabaseProvider =\n  DatabaseProvider(MongoConfig.fromPath(), registry)","title":"Create Registry"},{"location":"/database/provider.html#multiple-databases-access","text":"","title":"Multiple databases access"},{"location":"/database/reactive_streams.html","text":"","title":"Reactive Streams"},{"location":"/database/reactive_streams.html#reactive-streams","text":"The MongoDB Scala driver is built upon Reactive Streams simple-mongo wraps around the scala driver => Full support of Reactive Streams For Blocking Results (implicit) conversion to Result Objects is provided Conversion of Observable to Future is available\nScalaDriverDocs The MongoDB Scala Driver is an asynchronous and non blocking driver. Using the Observable model asynchronous events become simple, composable operations, freed from the complexity of nested callbacks. Additional Info for Reactive Streams JVM Additional Info for Mongo Scala Reactive Streams","title":"Reactive Streams"},{"location":"/database/reactive_streams.html#blocking-results","text":"Conversion is provided in the DAO instances with four Helper function for Observable[C]:\nFunction Name Function Result Sample Sample Result result C BookDAO.count().result() Long results Seq[C] PersonDAO.findAggregated(aggregator).results() Seq[Person] resultList List[C] UserDAO.find(“name”, “User”).resultList() List[User] resultOption Option[C] PersonDAO.find(Map(“id” -> 42)).resultOption() Option[Person]\nAll functions have an optional maxWait parameter (Default maxWait = 10 seconds).\nval listWithCustomMaxWait: List[Person] = PersonDAO.find().resultList(maxWait = 15)","title":"Blocking Results"},{"location":"/database/reactive_streams.html#implicit-result-conversion-blocking-","text":"To use implicit result conversion, you have to import the simple mongo base package object.\nimport com.sfxcode.nosql.mongo._\nAfter that, implicit conversion and other useful implicits (e.g. Map -> Bson) are available.\nval imagesCount: Long      = ImageFilesDAO.count()\nval seq: Seq[Person]       = PersonDAO.find()\nval list: List[Person]     = PersonDAO.find()\nval option: Option[Person] = PersonDAO.find(\"id\", 42)","title":"Implicit Result Conversion (Blocking)"},{"location":"/database/reactive_streams.html#future-results","text":"DAO Instances support (implicit) conversion to Future,\nval future: Future[Seq[Person]] = PersonDAO.find().asFuture()\nval mapped: Future[Seq[String]] =\n  future.map(personSeq => personSeq.map(p => p.name))\n\nval duration           = Duration(10, TimeUnit.SECONDS)\nval names: Seq[String] = Await.result(mapped, duration)","title":"Future Results"},{"location":"/database/bson.html","text":"","title":"Bson"},{"location":"/database/bson.html#bson","text":"","title":"Bson"},{"location":"/database/bson.html#bson-converter","text":"BSON converter is used for bidirectional converting of BSON data.\nSupports most Scala / Java types. Case class support Java Bean support pluggable","title":"BSON converter"},{"location":"/database/bson.html#usage","text":"","title":"Usage"},{"location":"/database/bson.html#tobson","text":"val result = BsonConverter.toBson(3) // result = BsonInt32(3)","title":"toBson"},{"location":"/database/bson.html#frombson","text":"val result = BsonConverter.fromBson(BsonInt32(3)) // result = 3","title":"fromBson"},{"location":"/database/bson.html#todocument","text":"case class Base(int: Int, Long: Long, float: Float, double: Double, \n      string: String, date: Date = new Date())\n\n    object Base {\n      def apply(): Base = new Base(1, 2, 3, 4, \"test\")\n    }\n\n   val document = Converter.toDocument(Base())\n\n    // Document((float,BsonDouble{value=3.0}), (string,BsonString{value='test'}), \n    // (double,BsonDouble{value=4.0}), (Long,BsonInt64{value=2}), (date,\n    // BsonDateTime{value=1531166757627}), (int,BsonInt32{value=1}))","title":"toDocument"},{"location":"/database/bson.html#plugins","text":"","title":"Plugins"},{"location":"/database/bson.html#example","text":"package com.sfxcode.nosql.mongo.bson\n\nimport org.bson.BsonValue\nimport org.joda.time.DateTime\nimport org.mongodb.scala.bson.{BsonDateTime, BsonNull}\n\nclass JodaConverterPlugin extends AbstractConverterPlugin {\n  override def customClassList: List[Class[_]] = List(classOf[DateTime])\n\n  override def toBson(value: Any): BsonValue =\n    value match {\n      case dt: DateTime => BsonDateTime(dt.toDate)\n      case _ =>\n        BsonNull()\n\n    }\n}","title":"Example"},{"location":"/database/relationships.html","text":"","title":"Relationships"},{"location":"/database/relationships.html#relationships","text":"","title":"Relationships"},{"location":"/database/relationships.html#info","text":"Normal Relationship handling is the use of embedded documents. However, sometimes there is a need for relationsips beetween collections. There is a Relations Trait to be used in case classes for easy relationship handling.","title":"Info"},{"location":"/database/relationships.html#relations-trait","text":"The Relations trait extends DAO case classes with relationship functions.\nrelatedRecordForOneToOne (OneToOneRelationship and reference vlue needed) relatedRecordsForOneToMany (OneToManyRelationship and reference vlue needed)","title":"Relations trait"},{"location":"/database/relationships.html#demo","text":"Simple Setup.\nUser Collection(should have one login and multiple friends) Login Collection Friend Collection\ncase class User(id: Long, name: String, loginId: String)\n  case class Login(id: String, email: String, password: String)\n  case class Friend(id: Long, name: String, userId: Long)\n  \n  object UserDAO extends MongoDAO[User](database, \"user\") \n  object LoginDAO extends MongoDAO[Login](database, \"login\")\n  object FriendDAO extends MongoDAO[Friend](database, \"friend\")\nFor relationship setup we create two Relationships in the UserDAO.\nOneToOne loginRelation (LoginDAO, key is id in user collection) OneToMany friendsRelation (FriendDAO, key is userId in friend collection)\nobject UserDAO extends MongoDAO[User](provider, \"user\") {\n  lazy val loginRelation   = OneToOneRelationship(LoginDAO, \"id\")\n  lazy val friendsRelation = OneToManyRelationship(SimplePersonDAO, \"userId\")\n}\nWe extend the User case class with the Relations trait and add relation specific functions.\nlogin (create an Option of Login) friends (create a List of Friend)\ncase class User(id: Long, name: String, loginId: String) extends Relations {\n\n  def login: Option[Login] = relatedRecordForOneToOne(UserDAO.loginRelation, loginId)\n\n  def friends: List[SimplePerson] = relatedRecordForOneToMany(UserDAO.friendsRelation, id)\n\n}","title":"Demo"},{"location":"/dao/index.html","text":"","title":"MongoDAO"},{"location":"/dao/index.html#mongodao","text":"","title":"MongoDAO"},{"location":"/dao/index.html#info","text":"MongoDAO is the core of this framework. The DAO Pattern simplifies database usage.\nThe MongoDAO object holds a reference to a MongoCollection and adds functions for easy collection handling.","title":"Info"},{"location":"/dao/index.html#features","text":"MongoDAO Base (Drop, Index, Count) MongoDAO CRUD (Create, Insert, Delete) MongoDAO Search (Search, Distinct, Aggregate)","title":"Features"},{"location":"/dao/index.html#usage","text":"A DatabaseProvider is needed.\nprivate val registry = fromProviders(classOf[Restaurant])\n\nval provider = DatabaseProvider(\"database\", registry)","title":"Usage"},{"location":"/dao/index.html#create-dao","text":"A Type Parameter is used for automatic Document to Class conversion (case classes needs to be registered).\nobject RestaurantDAO extends MongoDAO[Restaurant](provider, \"restaurants\")","title":"Create DAO"},{"location":"/dao/index.html#use-dao","text":"import com.sfxcode.nosql.mongo._\n\n  def restaurantsSize: Long = RestaurantDAO.count()\n\n  def findAllRestaurants:List[Restaurant] = RestaurantDAO.find()","title":"Use DAO"},{"location":"/dao/base.html","text":"","title":"MongoDAO Base"},{"location":"/dao/base.html#mongodao-base","text":"With an object extending MongoDAO class all functions on a specific MongoCollection can be easily used.\nBase Functions like\ndrop count createIndex\nare implemented.\nSearch Functions and CRUD Functions are available.\n##","title":"MongoDAO Base"},{"location":"/dao/base.html#additional-features","text":"","title":"Additional Features"},{"location":"/dao/base.html#synchronous-result","text":"All functions support synchronous result handling.\nUse pacckage import\nimport com.sfxcode.nosql.mongo._\nand append\n.result() for Single Result object .resultList() for List result object\nor use implicit conversion:\ndef restaurantsSize: Long = RestaurantDAO.count()","title":"Synchronous Result"},{"location":"/dao/base.html#raw-support","text":"Sometimes we need Raw Support (DAO maps to Document). This is automatically included in the MongoDAO class. Simply call Raw on your DAO Object.\nval pipeline = List(filterStage, groupStage, sortStage)\n\nval aggregated = PersonDAO.Raw.findAggregated(pipeline).resultList()","title":"Raw Support"},{"location":"/dao/base.html#base-functions","text":"","title":"Base Functions"},{"location":"/dao/base.html#drop","text":"Drop Collection.\ndef drop(): Observable[Void]","title":"Drop"},{"location":"/dao/base.html#count","text":"Count of collection with optional filter.\ndef count(filter: Bson = Document()): Observable[Long]","title":"Count"},{"location":"/dao/base.html#indexes","text":"def createIndex(key: Bson, options: IndexOptions = IndexOptions()): SingleObservable[String]\n\n// Simple Index creation\ndef createIndexForField(field: String, sortAscending: Boolean = true): SingleObservable[String]\n\ndef dropIndex(keys: Bson): SingleObservable[Void]\n\n// Simple Index delete\ndef dropIndexForName(name: String): SingleObservable[Void]","title":"Indexes"},{"location":"/dao/crud.html","text":"","title":"CRUD Functions"},{"location":"/dao/crud.html#crud-functions","text":"","title":"CRUD Functions"},{"location":"/dao/crud.html#info","text":"MongoDAO CRUD Collection functions.","title":"Info"},{"location":"/dao/crud.html#create","text":"def insertOne(value: A): Observable[Void]\n\ndef insertOne(value: A), options: InsertOneOptions: Observable[Void]\n\ndef insertMany(values: Seq[A]): Observable[Void]\n\ndef insertMany(values: Seq[A], options: InsertManyOptions): Observable[Void]","title":"Create"},{"location":"/dao/crud.html#update","text":"def replaceOne(value: A): Observable[UpdateResult]\n\ndef replaceOne(value: A, options: ReplaceOptions): Observable[UpdateResult]","title":"Update"},{"location":"/dao/crud.html#delete","text":"def deleteOne(value: A): Observable[DeleteResult]\n\ndef deleteOne(filter: Bson): Observable[DeleteResult]\n\ndef deleteMany(filter: Bson): Observable[DeleteResult]\n\ndef deleteAll(): Observable[DeleteResult]","title":"Delete"},{"location":"/dao/search.html","text":"","title":"Search Functions"},{"location":"/dao/search.html#search-functions","text":"","title":"Search Functions"},{"location":"/dao/search.html#info","text":"MongoDAO Search Functions","title":"Info"},{"location":"/dao/search.html#demo","text":"","title":"Demo"},{"location":"/dao/search.html#setup-imports","text":"// Filter helper functions\nimport com.sfxcode.nosql.mongo.Filter._\n// sort helper functions\nimport com.sfxcode.nosql.mongo.Sort._\n// implicits like Document from Map ...\nimport com.sfxcode.nosql.mongo._","title":"Setup imports"},{"location":"/dao/search.html#execute-search","text":"val females = PersonDAO.find(Map(\"gender\" -> \"female\"), \n    sortByKey(\"name\")).resultList()","title":"Execute Search"},{"location":"/gridfs/index.html","text":"","title":"GridFSDAO"},{"location":"/gridfs/index.html#gridfsdao","text":"","title":"GridFSDAO"},{"location":"/gridfs/index.html#info","text":"GridFSDAO adds MongoDB GridFS support.\nIt provides easy upload, download and metadata handling.\nSometimes also normal collections can be helpful for storing data.\nOfficial_MongoDB_Documentation Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.","title":"Info"},{"location":"/gridfs/index.html#usage","text":"A MongoDatabase and a bucket name is needed.","title":"Usage"},{"location":"/gridfs/index.html#create-dao","text":"/**\n  * use bucket name fs\n  */\n  object ImageFilesDAO extends GridFSDAO(database)\n\n  /**\n  * use bucket name images\n  */\n  object ImageFilesDAO extends GridFSDAO(database, \"images\")","title":"Create DAO"},{"location":"/gridfs/crud.html","text":"","title":"CRUD Functions"},{"location":"/gridfs/crud.html#crud-functions","text":"","title":"CRUD Functions"},{"location":"/gridfs/crud.html#create","text":"You need a filename, an input stream and some kind of metadata.\nPossible Metadata types:\nDocument Map Scala Case Class\nReturn Observable of ObjectId.\nImageFilesDAO.insertOne(filename, stream, metadata)","title":"Create"},{"location":"/gridfs/crud.html#update","text":"Official_MongoDB_Documentation Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.","title":"Update"},{"location":"/gridfs/crud.html#delete","text":"GridFSFile will be deleted by a given ObjectID.\nWith implicit conversion you can use for OID Parameter:\nObjectID GridFSFile String\n// for implicit conversion usage\n  import com.sfxcode.nosql.mongo._\n  \n  ImageFilesDAO.deleteOne(oid)","title":"Delete"},{"location":"/gridfs/metadata.html","text":"","title":"Metadata"},{"location":"/gridfs/metadata.html#metadata","text":"Metadata can be updated by the GridFSDAO object.","title":"Metadata"},{"location":"/gridfs/metadata.html#update-complete-metadata","text":"UpdateMetadata function will replace the whole metadata for one file.\nval value = Map(\"index\"->11, \"category\"->\"templates\")\nImageFilesDAO.updateMetadata(oid, value)","title":"Update complete Metadata"},{"location":"/gridfs/metadata.html#update-metadata-elements","text":"UpdateMetadataElement/s update some part of the metadata by a given filter.\nval elements =  Map(\"category\"->\"logos\")\n val filter = Map() // all files\n ImageFilesDAO.updateMetadataElements(filter, elements)","title":"Update Metadata elements"},{"location":"/collection/index.html","text":"","title":"Collection"},{"location":"/collection/index.html#collection","text":"Aggregation","title":"Collection"},{"location":"/collection/aggregation.html","text":"","title":"Aggregation"},{"location":"/collection/aggregation.html#aggregation","text":"","title":"Aggregation"},{"location":"/collection/aggregation.html#info","text":"MongoDB support an easy to use Aggregation Handling.","title":"Info"},{"location":"/collection/aggregation.html#demo","text":"","title":"Demo"},{"location":"/collection/aggregation.html#setup-imports","text":"import com.sfxcode.nosql.mongo.Aggregate._\nimport com.sfxcode.nosql.mongo._\nimport com.sfxcode.nosql.mongo.dao.PersonSpecification","title":"Setup imports"},{"location":"/collection/aggregation.html#define-stages","text":"val filterStage: Bson = filter(and(equal(\"gender\", \"female\"), notNullFilter(\"balance\")))\n\nval groupStage: Bson = group(Map(\"age\" -> \"$age\"), sumField(\"balance\"), firstField(\"age\"))\n\nval sortStage: Bson = sort(sortByKey(\"age\"))","title":"Define stages"},{"location":"/collection/aggregation.html#execute-aggregation","text":"Important In most cases we have to use the RAW attribute, because the aggregation result not follows the case class pattern. RAW returns always Documents instead of case classes.\nval pipeline = List(filterStage, groupStage, sortStage)\n\nval aggregated = PersonDAO.Raw.findAggregated(pipeline).resultList()","title":"Execute Aggregation"},{"location":"/collection/aggregation.html#convert-result","text":"For easy result handling, using the implicit Document to Map conversion can be useful.\nval list: List[Map[String, Any]] = aggregated","title":"Convert Result"},{"location":"/server.html","text":"","title":"LocalServer"},{"location":"/server.html#localserver","text":"simple-mongo supports LocalServer by mongo-java-server (since 2.0.1).\nUseful for tests and small offline Apps. Dependency to mongo-java-server is marked as provided, you have to import the dependency by yourself.\n// Base dependency\nlibraryDependencies += \"de.bwaldvogel\" % \"mongo-java-server\" % \"1.28.0\"\n\n// H2 Backend\nlibraryDependencies += \"de.bwaldvogel\" % \"mongo-java-server-h2-backend\" % \"1.28.0\"","title":"LocalServer"},{"location":"/server.html#localserver-modes","text":"InMemory H2 InMemory H2 file based","title":"LocalServer Modes"},{"location":"/server.html#setup","text":"LocalServer is done by ServerConfig. For InMemory tests no special stup is needed.\nval LocalTestServer = LocalServer()","title":"Setup"},{"location":"/server.html#setup-with-application-config","text":"unit.test.local.mongo.server {\n  host = \"localhost\"\n  port = 28028\n  serverName = \"local-unit-test-server\"\n  backend = \"h2\"\n  h2 {\n    inMemory = false\n    path = \"\" // without path set a random temp file is created\n  }\n}\n\nunit.test.mongo.local {\n  database = \"simple-mongo-unit-test\"\n  host = \"localhost\"\n  port = 28028\n  applicationName = \"simple-mongo-config-test\"\n}","title":"Setup with application config"},{"location":"/changes.html","text":"","title":"Version History"},{"location":"/changes.html#version-history","text":"","title":"Version History"},{"location":"/changes.html#current-version","text":"","title":"Current Version"},{"location":"/changes.html#history","text":"# Changes #\n\n## Versions\n\n### 2.0.1\n* Mongo Java Server Support\n* LocalServer, ServerConfig added\n\n### 2.0.0\n* mongo package no longer extends MongoImplcits => Use MongoImplcits trait if needed\n\n### 1.9.7\n* Support for Dot notation in documents\n* extend Document functions with getValue. updateValue, getIntValue ... (with dot support)\n\n### 1.9.4\n* Rewrite Docs and Samples\n* Specs Setup Redesign\n* Added more Specs (Coverage min from 60 to 70)\n\n### 1.9.2\n* scala 2.13.2\n* Minor Fixes\n\n### 1.9.1\n* database provider: runCommand added\n* database provider: addChangeObserver added\n* DAO changeObserver added\n* DAO stats (GridFSDAO fileStats, chunkStats) as case class added\n\n### 1.9.0\n\n* ObservableIncludes changed method names for better understanding =>\n  - result (A), results (Seq[A]), resultOption (Option[A]), resultList (List[A])\n  - **Breaking Change** : dropped => headResult (use now result)\n  - **Breaking Change** :  changed => result (old Option[A], new A) => use resultOption instead\n* Add Bulkwrite to Crud Operations\n* MongoDAO supports Json Import from File\n\n### 1.8.2\n\n* GridFSStreamObserver suports now completed and resultLength\n* implcit resultLength (in bytes) for GridFSStreamObserver\n\n### 1.8.0\n\n* mongo-scala-driver 4.0.2\n* maxWaitQueueSize is removed (since mongo-scala-driver 4.0.0)\n* GridFS Refactoring (Download / Upload use now reactive streams)\n* More Index Functions added\n\n### 1.7.1\n* [mongo-scala-driver 2.9.0](https://mongodb.github.io/mongo-scala-driver/2.9/changelog/)\n\n\n### 1.7.0\n* [mongo-scala-driver 2.8.0](https://mongodb.github.io/mongo-scala-driver/2.8/changelog/)\n* MongoDB Driver Async 3.12.0\n* \n### 1.6.7\n* Typesave Config 1.4.0\n\n### 1.6.6\n* Scala 2.13\n* mongo-scala-driver 2.7.0\n* MongoDB Driver Async 3.11.0\n\n### 1.6.5\n* MongoConfig added (also for config values in application.conf)\n* MongoPoolOptions added\n* Codecs prepared for Scala 2.13\n* Additional index functions added\n* Drop Scala 2.11 support\n* Docs updated\n\n### 1.6.2\n* mongo-scala-driver 2.6.0\n* MongoDB Driver Async 3.10.0\n* sbt.version = 1.2.8\n\n### 1.6.1\n* sbt.version = 1.2.7\n\n### 1.6.0\n\n* mongo-scala-driver 2.5.0\n* scalafmt support\n* scalacheck support\n\n### 1.5.6\n\n* mongo-scala-driver 2.4.2\n\n### 1.5.5\n\n* mongo-scala-driver 2.4.1\n\n### 1.5.3\n\n* scala 2.11.12\n* BsonConverter Char support\n\n\n### 1.5.2\n\n* GridFSDAO extends Metadata\n* Metadata - updateMetadata added\n* Metadata - updateMetadataElement/s added\n\n### 1.5.1\n\n* DatabaseProvider refactored\n* ObservableImplicits to package object added\n* update docs for Observable\n\n### 1.5.0\n* GridFSSupport\n\n\n### 1.4.0\n*  dropped operations with pattern <name>Result (use result, list result or implicit conversion instead)\n*  introduce Database Functions trait\n*  update docs\n\n\n### 1.3.1\n* update mongo-scala-driver to 2.4.0\n* Operations Base count method support CountOptions\n\n\n### 1.3.0\n\n* Crud refactoring\n* CrudObserver Trait (optional usage)\n\n\n### 1.2.0\n\n* Relations added\n* Field added (used in Aggregation)\n* Aggregation Specs added\n* implicit Document(s) to Map(s) Conversion\n* method sort in Sort object renamed to sortByKey\n\n### 1.1.0\n\n* update mongo-scala-driver to 2.3.0\n* update to Scala 2.12.6\n\n### 1.0.5\n\n* update to Scala 2.12.5\n\n### 1.0.4\n\n* update to mongo scala driver 2.2.1\n\n### 1.0.3\n\n* gh-pages added\n* test fixes\n\n### 1.0.2\n\n* update to mongo scala driver 2.2.0\n\n### 1.0.1\n\n* BuildInfo added\n* dependencies updated\n* plugins updated\n* Index support addded","title":"History"}]}