{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"simple-mongo"},{"location":"/index.html#simple-mongo","text":"A library for easy usage of the mongo-scala-driver.\nFeatures:\nEasy Config with DatabaseProvider Implement the DAO Pattern for simple MongoDB database usage (MongoDAO) Enhanced BSON conversion support (Converter) GridFS support (GridFSDAO) Relationships","title":"simple-mongo"},{"location":"/index.html#additional-documentation","text":"mongo-scala-driver MongoDB","title":"Additional Documentation"},{"location":"/index.html#dependency-setup","text":"Support Scala 2.12 and Scala 2.13.\nsbt libraryDependencies += \"com.sfxcode.nosql\" %% \"simple-mongo\" % \"1.8.0\" Maven <dependency>\n  <groupId>com.sfxcode.nosql</groupId>\n  <artifactId>simple-mongo_2.12</artifactId>\n  <version>1.8.0</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.sfxcode.nosql', name: 'simple-mongo_2.12', version: '1.8.0'\n}","title":"Dependency Setup"},{"location":"/index.html#licence","text":"Apache 2","title":"Licence"},{"location":"/database_provider.html","text":"","title":"DatabaseProvider"},{"location":"/database_provider.html#databaseprovider","text":"DatabaseProvider is the central repository for MongoClient, databases, collections. It is referenced by the MongoDAO Patttern.","title":"DatabaseProvider"},{"location":"/database_provider.html#mongoconfig","text":"MongoConfig holds all the neded Data for creating a MongoClient. It is used for DatabaseProvider creation.\nKey Description Default value database default database to use host 127.0.0.1 port 27017 applicationName simple-mongo-app userName used for Authentification password used for Authentification poolOptions MongoPoolOptions() customClientSettings None","title":"MongoConfig"},{"location":"/database_provider.html#mongopooloptions","text":"Key Default value maxConnectionIdleTime 60 maxSize 50 minSize 0 maxWaitQueueSize 500 DefaultMaintenanceInitialDelay 0","title":"MongoPoolOptions"},{"location":"/database_provider.html#create-mongoconfig-with-properties","text":"Example:\nval config = MongoConfig(\"my_database\", host = \"localhost\",\n        applicationName = \"Awesome Application Name\")","title":"Create MongoConfig with properties"},{"location":"/database_provider.html#create-mongoconfig-with-config","text":"Create application.conf:\nconfig.test.auth.mongo {\n  database = \"another_database\"\n  host = \"localhost\"\n  port = 270007\n  applicationName = \"simple-mongo-config-test-with-auth\"\n  userName = \"admin_user\"\n  password = \"1234\"\n  pool {\n    minSize = 5\n    maxSize = 100\n  }\nval config = MongoConfig.fromPath(\"config.test.auth.mongo\")","title":"Create MongoConfig with config"},{"location":"/database_provider.html#create-mongoconfig-with-custom-clientsettings","text":"val config = MongoConfig(\"my_database\", customClientSettings = Some(myClientSettings))","title":"Create MongoConfig with custom ClientSettings"},{"location":"/database_provider.html#registries","text":"","title":"Registries"},{"location":"/dao/index.html","text":"","title":"MongoDAO"},{"location":"/dao/index.html#mongodao","text":"","title":"MongoDAO"},{"location":"/dao/index.html#info","text":"MongoDAO is the core of this framework. The DAO Pattern simplifies database usage.\nThe MongoDAO object holds a reference to a MongoCollection and adds functions for easy collection handling.","title":"Info"},{"location":"/dao/index.html#features","text":"MongoDAO Base (Drop, Index, Count) MongoDAO CRUD (Create, Insert, Delete) MongoDAO Search (Search, Distinct, Aggregate)","title":"Features"},{"location":"/dao/index.html#usage","text":"A DatabaseProvider is needed.\nprivate val registry = fromProviders(classOf[Restaurant])\n\nval provider = DatabaseProvider(\"database\", registry)","title":"Usage"},{"location":"/dao/index.html#create-dao","text":"A Type Parameter is used for automatic Document to Class conversion (case classes needs to be registered).\nobject RestaurantDAO extends MongoDAO[Restaurant](provider, \"restaurants\")","title":"Create DAO"},{"location":"/dao/index.html#use-dao","text":"import com.sfxcode.nosql.mongo._\n\n  def restaurantsSize: Long = RestaurantDAO.count()\n\n  def findAllRestaurants:List[Restaurant] = RestaurantDAO.find()","title":"Use DAO"},{"location":"/dao/base.html","text":"","title":"MongoDAO Base"},{"location":"/dao/base.html#mongodao-base","text":"With an object extending MongoDAO class all functions on a specific MongoCollection can be easily used.\nBase Functions like\ndrop count createIndex\nare implemented.\nSearch Functions and CRUD Functions are available.\n##","title":"MongoDAO Base"},{"location":"/dao/base.html#additional-features","text":"","title":"Additional Features"},{"location":"/dao/base.html#synchronous-result","text":"All functions support synchronous result handling.\nUse pacckage import\nimport com.sfxcode.nosql.mongo._\nand append\n.headResult() for Single Result object .resultList() for List result object\nor use implicit conversion:\ndef restaurantsSize: Long = RestaurantDAO.count()","title":"Synchronous Result"},{"location":"/dao/base.html#raw-support","text":"Sometimes we need Raw Support (DAO maps to Document). This is automatically included in the MongoDAO class. Simply call Raw on your DAO Object.\nval aggregator = List(filterStage, groupStage, sortStage)\n\nval aggregated = PersonDAO.Raw.findAggregated(aggregator).resultList()","title":"Raw Support"},{"location":"/dao/base.html#base-functions","text":"","title":"Base Functions"},{"location":"/dao/base.html#drop","text":"Drop Collection.\ndef drop(): Observable[Void]","title":"Drop"},{"location":"/dao/base.html#count","text":"Count of collection with optional filter.\ndef count(filter: Bson = Document()): Observable[Long]","title":"Count"},{"location":"/dao/base.html#indexes","text":"def createIndex(key: Bson, options: IndexOptions = IndexOptions()): SingleObservable[String]\n\n// Simple Index creation\ndef createIndexForField(field: String, sortAscending: Boolean = true): SingleObservable[String]\n\ndef dropIndex(keys: Bson): SingleObservable[Void]\n\n// Simple Index delete\ndef dropIndexForName(name: String): SingleObservable[Void]","title":"Indexes"},{"location":"/dao/crud.html","text":"","title":"CRUD Functions"},{"location":"/dao/crud.html#crud-functions","text":"","title":"CRUD Functions"},{"location":"/dao/crud.html#info","text":"MongoDAO CRUD Collection functions.","title":"Info"},{"location":"/dao/crud.html#create","text":"def insertOne(value: A): Observable[Void]\n\ndef insertOne(value: A), options: InsertOneOptions: Observable[Void]\n\ndef insertMany(values: Seq[A]): Observable[Void]\n\ndef insertMany(values: Seq[A], options: InsertManyOptions): Observable[Void]","title":"Create"},{"location":"/dao/crud.html#update","text":"def replaceOne(value: A): Observable[UpdateResult]\n\ndef replaceOne(value: A, options: ReplaceOptions): Observable[UpdateResult]","title":"Update"},{"location":"/dao/crud.html#delete","text":"def deleteOne(value: A): Observable[DeleteResult]\n\ndef deleteOne(filter: Bson): Observable[DeleteResult]\n\ndef deleteMany(filter: Bson): Observable[DeleteResult]\n\ndef deleteAll(): Observable[DeleteResult]","title":"Delete"},{"location":"/dao/search.html","text":"","title":"Search Functions"},{"location":"/dao/search.html#search-functions","text":"","title":"Search Functions"},{"location":"/dao/search.html#info","text":"MongoDAO Search Functions","title":"Info"},{"location":"/dao/search.html#demo","text":"","title":"Demo"},{"location":"/dao/search.html#setup-imports","text":"// Filter helper functions\nimport com.sfxcode.nosql.mongo.Filter._\n// sort helper functions\nimport com.sfxcode.nosql.mongo.Sort._\n// implicits like Document from Map ...\nimport com.sfxcode.nosql.mongo._","title":"Setup imports"},{"location":"/dao/search.html#execute-search","text":"val females = PersonDAO.find(Map(\"gender\" -> \"female\"), \n    sortByKey(\"name\")).resultList()","title":"Execute Search"},{"location":"/gridfs/index.html","text":"","title":"GridFSDAO"},{"location":"/gridfs/index.html#gridfsdao","text":"","title":"GridFSDAO"},{"location":"/gridfs/index.html#info","text":"GridFSDAO adds MongoDB GridFS support.\nIt provides easy upload, download and metadata handling.\nSometimes also normal collections can be helpful for storing data.\nOfficial_MongoDB_Documentation Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.","title":"Info"},{"location":"/gridfs/index.html#usage","text":"A MongoDatabase and a bucket name is needed.","title":"Usage"},{"location":"/gridfs/index.html#create-dao","text":"/**\n  * use bucket name fs\n  */\n  object ImageFilesDAO extends GridFSDAO(database)\n\n  /**\n  * use bucket name images\n  */\n  object ImageFilesDAO extends GridFSDAO(database, \"images\")","title":"Create DAO"},{"location":"/gridfs/crud.html","text":"","title":"CRUD Functions"},{"location":"/gridfs/crud.html#crud-functions","text":"","title":"CRUD Functions"},{"location":"/gridfs/crud.html#create","text":"You need a filename, an input stream and some kind of metadata.\nPossible Metadata types:\nDocument Map Scala Case Class\nReturn Observable of ObjectId.\nImageFilesDAO.insertOne(filename, stream, metadata)","title":"Create"},{"location":"/gridfs/crud.html#update","text":"Official_MongoDB_Documentation Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.","title":"Update"},{"location":"/gridfs/crud.html#delete","text":"GridFSFile will be deleted by a given ObjectID.\nWith implicit conversion you can use for OID Parameter:\nObjectID GridFSFile String\n// for implicit conversion usage\n  import com.sfxcode.nosql.mongo._\n  \n  ImageFilesDAO.deleteOne(oid)","title":"Delete"},{"location":"/gridfs/metadata.html","text":"","title":"Metadata"},{"location":"/gridfs/metadata.html#metadata","text":"Metadata can be updated by the GridFSDAO object.","title":"Metadata"},{"location":"/gridfs/metadata.html#update-complete-metadata","text":"UpdateMetadata function will replace the whole metadata for one file.\nval value = Map(\"index\"->11, \"category\"->\"templates\")\nImageFilesDAO.updateMetadata(oid, value)","title":"Update complete Metadata"},{"location":"/gridfs/metadata.html#update-metadata-elements","text":"UpdateMetadataElement/s update some part of the metadata by a given filter.\nval elements =  Map(\"category\"->\"logos\")\n val filter = Map() // all files\n ImageFilesDAO.updateMetadataElements(filter, elements)","title":"Update Metadata elements"},{"location":"/features/index.html","text":"","title":"Features"},{"location":"/features/index.html#features","text":"Aggregation Converter Observable Relationshpips","title":"Features"},{"location":"/features/aggregation.html","text":"# Aggregation","title":"Info"},{"location":"/features/aggregation.html#info","text":"MongoDB support an easy to use Aggregation Handling.","title":"Info"},{"location":"/features/aggregation.html#demo","text":"","title":"Demo"},{"location":"/features/aggregation.html#setup-imports","text":"import com.sfxcode.nosql.mongo.Aggregate._\nimport com.sfxcode.nosql.mongo._","title":"Setup imports"},{"location":"/features/aggregation.html#define-stages","text":"val filterStage: Bson = filter(and(equal(\"gender\", \"female\"), notNullFilter(\"balance\")))\n\nval groupStage: Bson = group(Map(\"age\" -> \"$age\"), sumField(\"balance\"), firstField(\"age\"))\n\nval sortStage: Bson = sort(sortByKey(\"age\"))","title":"Define stages"},{"location":"/features/aggregation.html#execute-aggregation","text":"Important In most cases we have to use the RAW attribute, because the aggregation result not follows the case class pattern. RAW returns always Documents instead of case classes.\nval aggregator = List(filterStage, groupStage, sortStage)\n\nval aggregated = PersonDAO.Raw.findAggregated(aggregator).resultList()","title":"Execute Aggregation"},{"location":"/features/aggregation.html#convert-result","text":"For easy result handling, using the implicit Document to Map conversion can be useful.\nval list: List[Map[String, Any]] = aggregated","title":"Convert Result"},{"location":"/features/relationships.html","text":"","title":"Relationships"},{"location":"/features/relationships.html#relationships","text":"","title":"Relationships"},{"location":"/features/relationships.html#info","text":"Normal Relationship handling is the use of embedded documents. However, sometimes there is a need for relationsips beetween collections. There is a Relations Trait to be used in case classes for easy relationship handling.","title":"Info"},{"location":"/features/relationships.html#relations-trait","text":"The Relations trait extends DAO case classes with relationship functions.\nrelatedRecordForOneToOne (OneToOneRelationship and reference vlue needed) relatedRecordsForOneToMany (OneToManyRelationship and reference vlue needed)","title":"Relations trait"},{"location":"/features/relationships.html#demo","text":"Simple Setup.\nUser Collection(should have one login and multiple friends) Login Collection Friend Collection\ncase class User(id: Long, name: String, loginId: String)\n  case class Login(id: String, email: String, password: String)\n  case class Friend(id: Long, name: String, userId: Long)\n  \n  object UserDAO extends MongoDAO[User](database, \"user\") \n  object LoginDAO extends MongoDAO[Login](database, \"login\")\n  object FriendDAO extends MongoDAO[Friend](database, \"friend\")\nFor relationship setup we create two Relationships in the UserDAO.\nOneToOne loginRelation (LoginDAO, key is id in user collection) OneToMany friendsRelation (FriendDAO, key is userId in friend collection)\nobject UserDAO extends MongoDAO[User](provider, \"user\") {\n  lazy val loginRelation = OneToOneRelationship(LoginDAO, \"id\")\n  lazy val friendsRelation = OneToManyRelationship(FriendDAO, \"userId\")\n}\nWe extend the User case class with the Relations trait and add relation specific functions.\nlogin (create an Option of Login) friends (create a List of Friend)\ncase class User(id: Long, name: String, loginId: String) extends Relations {\n\n  def login: Option[Login] = relatedRecordForOneToOne(UserDAO.loginRelation, loginId)\n\n  def friends: List[Friend] = relatedRecordForOneToMany(UserDAO.friendsRelation, id)\n\n}","title":"Demo"},{"location":"/features/observable.html","text":"","title":"Observable"},{"location":"/features/observable.html#observable","text":"","title":"Observable"},{"location":"/features/observable.html#info","text":"MongoDB_Scala_Driver_Documentation The MongoDB Scala Driver is an asynchronous and non blocking driver. Using the Observable model asynchronous events become simple, composable operations, freed from the complexity of nested callbacks.\nSee MongoDB Scala Driver Documentation.","title":"Info"},{"location":"/features/observable.html#dealing-with-observables","text":"","title":"Dealing with Observables"},{"location":"/features/observable.html#as-future","text":"def findAllRestaurants: Future[Seq[Restaurant]] = \n      RestaurantDAO.find().asFuture()","title":"As Future"},{"location":"/features/observable.html#result-functions","text":"Convert Observable to result object. Import mongo package is needed.\nFunctions headResult anf resultList have an optional maxWait in seconds parameter (Default maxWait = 10 seconds).\nimport com.sfxcode.nosql.mongo._\n\n  def restaurantsSize = RestaurantDAO.count().headResult()\n  \n  def findAllRestaurants = RestaurantDAO.find().resultList(maxWait = 20)","title":"Result Functions"},{"location":"/features/observable.html#implicit-result-functions","text":"Implicit result conversion to a given type. Import mongo package is needed.\nimport com.sfxcode.nosql.mongo._\n\n  def restaurantsSize: Long = RestaurantDAO.count()\n  \n  def findAllRestaurants:List[Restaurant] = RestaurantDAO.find()","title":"Implicit Result Functions"},{"location":"/features/converter.html","text":"","title":"Converter"},{"location":"/features/converter.html#converter","text":"","title":"Converter"},{"location":"/features/converter.html#info","text":"BSON converter is used for bidirectional converting of BSON data.\nSupports most Scala / Java types. Case class support Java Bean support pluggable","title":"Info"},{"location":"/features/converter.html#usage","text":"","title":"Usage"},{"location":"/features/converter.html#tobson","text":"val result = BsonConverter.toBson(3) // result = BsonInt32(3)","title":"toBson"},{"location":"/features/converter.html#frombson","text":"val result = BsonConverter.fromBson(BsonInt32(3)) // result = 3","title":"fromBson"},{"location":"/features/converter.html#todocument","text":"case class Base(int: Int, Long: Long, float: Float, double: Double, \n      string: String, date: Date = new Date())\n\n    object Base {\n      def apply(): Base = new Base(1, 2, 3, 4, \"test\")\n    }\n\n   val document = Converter.toDocument(Base())\n\n    // Document((float,BsonDouble{value=3.0}), (string,BsonString{value='test'}), \n    // (double,BsonDouble{value=4.0}), (Long,BsonInt64{value=2}), (date,\n    // BsonDateTime{value=1531166757627}), (int,BsonInt32{value=1}))","title":"toDocument"},{"location":"/features/converter.html#plugins","text":"","title":"Plugins"},{"location":"/features/converter.html#example","text":"package com.sfxcode.nosql.mongo.converter\n\nimport com.sfxcode.nosql.mongo.bson.AbstractConverterPlugin\nimport org.bson.BsonValue\nimport org.joda.time.DateTime\nimport org.mongodb.scala.bson.{ BsonDateTime, BsonNull }\n\nclass JodaConverterPlugin extends AbstractConverterPlugin {\n  override def customClassList: List[Class[_]] = List(classOf[DateTime])\n\n  override def toBson(value: Any): BsonValue =\n    value match {\n      case dt: DateTime => BsonDateTime(dt.toDate)\n      case _ =>\n        BsonNull()\n\n    }\n}","title":"Example"},{"location":"/tutorial/index.html","text":"","title":"Tutorial"},{"location":"/tutorial/index.html#tutorial","text":"Part 1 : Setup Database and Resources Part 2 : Database Part 3 : Function Trait Pattern Part 4 : Demo Application","title":"Tutorial"},{"location":"/tutorial/setup.html","text":"","title":"Part 1 - Setup"},{"location":"/tutorial/setup.html#part-1-setup","text":"","title":"Part 1 - Setup"},{"location":"/tutorial/setup.html#mongodb-demo-database","text":"","title":"MongoDB Demo Database"},{"location":"/tutorial/setup.html#setup","text":"Use Import from MongoDB Website:\nRestaurant Data Import","title":"Setup"},{"location":"/tutorial/setup.html#sample-document","text":"A sample document in the restaurants collection:\n{\n  \"address\": {\n     \"building\": \"1007\",\n     \"coord\": [ -73.856077, 40.848447 ],\n     \"street\": \"Morris Park Ave\",\n     \"zipcode\": \"10462\"\n  },\n  \"borough\": \"Bronx\",\n  \"cuisine\": \"Bakery\",\n  \"grades\": [\n     { \"date\": { \"$date\": 1393804800000 }, \"grade\": \"A\", \"score\": 2 },\n     { \"date\": { \"$date\": 1378857600000 }, \"grade\": \"A\", \"score\": 6 },\n     { \"date\": { \"$date\": 1358985600000 }, \"grade\": \"A\", \"score\": 10 },\n     { \"date\": { \"$date\": 1322006400000 }, \"grade\": \"A\", \"score\": 9 },\n     { \"date\": { \"$date\": 1299715200000 }, \"grade\": \"B\", \"score\": 14 }\n  ],\n  \"name\": \"Morris Park Bake Shop\",\n  \"restaurant_id\": \"30075445\"\n}","title":"Sample Document"},{"location":"/tutorial/setup.html#scala-case-classes-for-restaurant-document","text":"case class Address(street: String, building: String, zipcode: String, coord: List[Double])\n\ncase class Grade(date: Date, grade: String, score: Int)\n\ncase class Restaurant(\n  restaurant_id: String,\n  name: String,\n  borough: String,\n  cuisine: String,\n  grades: List[Grade],\n  address: Address,\n  _id: ObjectId = new ObjectId())","title":"Scala case classes for Restaurant document"},{"location":"/tutorial/database.html","text":"","title":"Part 2 - Database"},{"location":"/tutorial/database.html#part-2-database","text":"","title":"Part 2 - Database"},{"location":"/tutorial/database.html#info","text":"The database provides static import to our DAO objects.","title":"Info"},{"location":"/tutorial/database.html#imports","text":"import java.util.Date\n\nimport com.sfxcode.nosql.mongo.MongoDAO\nimport com.sfxcode.nosql.mongo.database.DatabaseProvider\nimport org.bson.codecs.configuration.CodecRegistries._\nimport org.mongodb.scala.bson.ObjectId\nimport org.mongodb.scala.bson.codecs.Macros._","title":"Imports"},{"location":"/tutorial/database.html#case-classes-for-document-representation","text":"case class Address(street: String, building: String, zipcode: String, coord: List[Double])\n\ncase class Grade(date: Date, grade: String, score: Int)\n\ncase class Restaurant(\n  restaurant_id: String,\n  name: String,\n  borough: String,\n  cuisine: String,\n  grades: List[Grade],\n  address: Address,\n  _id: ObjectId = new ObjectId())","title":"case classes for document representation"},{"location":"/tutorial/database.html#registry-and-database","text":"scala-mongo-driver use a registry pattern for deserialization\nprivate val registry = fromProviders(classOf[Restaurant], classOf[Address], classOf[Grade])\n\nval provider = DatabaseProvider.fromPath(\"test.mongo\", registry)","title":"Registry and database"},{"location":"/tutorial/database.html#restaurant-dao","text":"object RestaurantDAO extends MongoDAO[Restaurant](provider, \"another_database_name:restaurants\")","title":"Restaurant DAO"},{"location":"/tutorial/database.html#usage","text":"Create Database object\nobject RestaurantDatabase {\n\n// case classes ...\n\n// registry and database setup ...\n\nobject RestaurantDAO extends MongoDAO[Restaurant](database, \"restaurants\")\n\n// more DAO objects\n}\nStatic Import and Application\n// static import of needed DAO objects\n   import my.namespace.RestaurantDatabase._\n   \n   // ... some code","title":"Usage"},{"location":"/tutorial/functions.html","text":"","title":"Part 3 - Functions"},{"location":"/tutorial/functions.html#part-3-functions","text":"","title":"Part 3 - Functions"},{"location":"/tutorial/functions.html#info","text":"Use a functions trait to define some commonly used funtions.","title":"Info"},{"location":"/tutorial/functions.html#imports","text":"// static import of needed DAO objects\nimport com.sfxcode.nosql.mongo.demo.restaurant.RestaurantDemoDatabase._\n\n// static import of mongo package object for needed implicits\nimport com.sfxcode.nosql.mongo._","title":"Imports"},{"location":"/tutorial/functions.html#simple-application","text":"/**\n * single result with implicit conversion to Entity Option\n */\ndef findRestaurantByName(name: String): Option[Restaurant] =\n  RestaurantDAO.find(\"name\", name)\n\ndef restaurantsSize: Long = RestaurantDAO.count()\n\n/**\n * result with implicit conversion to List of Entities\n */\ndef findAllRestaurants(filterValues: Map[String, Any] = Map()): List[Restaurant] =\n  RestaurantDAO.find(filterValues)","title":"Simple Application"},{"location":"/tutorial/application.html","text":"","title":"Part 4 - Application"},{"location":"/tutorial/application.html#part-4-application","text":"","title":"Part 4 - Application"},{"location":"/tutorial/application.html#info","text":"This Demo Application should demonstrate the basic usage of simple-mongo.","title":"Info"},{"location":"/tutorial/application.html#simple-application","text":"object RestaurantDemoApp extends App with RestaurantDemoDatabaseFunctions {\n\n  // find specific restaurant by name as Option Result\n  val restaurant = findRestaurantByName(\"Dj Reynolds Pub And Restaurant\")\n\n  println(restaurant)\n\n  // use count function\n  println(restaurantsSize)\n\n  // find restaurants by filter\n  private val filter = Map(\"address.zipcode\" -> \"10075\", \"cuisine\" -> \"Italian\")\n  val restaurants = findAllRestaurants(filter)\n\n  restaurants.sortBy(r => r.name).foreach(r => println(r.name))\n\n}","title":"Simple Application"},{"location":"/changes.html","text":"","title":"Version History"},{"location":"/changes.html#version-history","text":"","title":"Version History"},{"location":"/changes.html#current-version","text":"","title":"Current Version"},{"location":"/changes.html#history","text":"# Changes #\n\n## Versions\n\n### 1.8.0\n\n* mongo-scala-driver 4.0.2\n* maxWaitQueueSize is removed (since mongo-scala-driver 4.0.0)\n* GridFS Refactoring (Download / Upload use now reactive streams)\n* More Index Functions added\n\n### 1.7.1\n* [mongo-scala-driver 2.9.0](https://mongodb.github.io/mongo-scala-driver/2.9/changelog/)\n\n\n### 1.7.0\n* [mongo-scala-driver 2.8.0](https://mongodb.github.io/mongo-scala-driver/2.8/changelog/)\n* MongoDB Driver Async 3.12.0\n* \n### 1.6.7\n* Typesave Config 1.4.0\n\n### 1.6.6\n* Scala 2.13\n* mongo-scala-driver 2.7.0\n* MongoDB Driver Async 3.11.0\n\n### 1.6.5\n* MongoConfig added (also for config values in application.conf)\n* MongoPoolOptions added\n* Codecs prepared for Scala 2.13\n* Additional index functions added\n* Drop Scala 2.11 support\n* Docs updated\n\n### 1.6.2\n* mongo-scala-driver 2.6.0\n* MongoDB Driver Async 3.10.0\n* sbt.version = 1.2.8\n\n### 1.6.1\n* sbt.version = 1.2.7\n\n### 1.6.0\n\n* mongo-scala-driver 2.5.0\n* scalafmt support\n* scalacheck support\n\n### 1.5.6\n\n* mongo-scala-driver 2.4.2\n\n### 1.5.5\n\n* mongo-scala-driver 2.4.1\n\n### 1.5.3\n\n* scala 2.11.12\n* BsonConverter Char support\n\n\n### 1.5.2\n\n* GridFSDAO extends Metadata\n* Metadata - updateMetadata added\n* Metadata - updateMetadataElement/s added\n\n### 1.5.1\n\n* DatabaseProvider refactored\n* ObservableImplicits to package object added\n* update docs for Observable\n\n### 1.5.0\n* GridFSSupport\n\n\n### 1.4.0\n*  dropped operations with pattern <name>Result (use headResult, list result or implicit conversion instead)\n*  introduce Database Functions trait\n*  update docs\n\n\n### 1.3.1\n* update mongo-scala-driver to 2.4.0\n* Operations Base count method support CountOptions\n\n\n### 1.3.0\n\n* Crud refactoring\n* CrudObserver Trait (optional usage)\n\n\n### 1.2.0\n\n* Relations added\n* Field added (used in Aggregation)\n* Aggregation Specs added\n* implicit Document(s) to Map(s) Conversion\n* method sort in Sort object renamed to sortByKey\n\n### 1.1.0\n\n* update mongo-scala-driver to 2.3.0\n* update to Scala 2.12.6\n\n### 1.0.5\n\n* update to Scala 2.12.5\n\n### 1.0.4\n\n* update to mongo scala driver 2.2.1\n\n### 1.0.3\n\n* gh-pages added\n* test fixes\n\n### 1.0.2\n\n* update to mongo scala driver 2.2.0\n\n### 1.0.1\n\n* BuildInfo added\n* dependencies updated\n* plugins updated\n* Index support addded","title":"History"}]}