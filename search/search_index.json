{"docs":[{"location":"/paradox.json","text":"","title":""},{"location":"/index.html","text":"","title":"simple-mongo"},{"location":"/index.html#simple-mongo","text":"A library for easy usage of the mongo-scala-driver.\nFeatures:\nImplement the DAO Pattern for easy MongoDB database usage. Enhanced BSON conversion support. GridFS support.","title":"simple-mongo"},{"location":"/index.html#additional-documentation","text":"mongo-scala-driver MongoDB","title":"Additional Documentation"},{"location":"/index.html#dependency-setup","text":"Support Scala 2.11 and Scala 2.12.\nresolvers += \"sxfcode Bintray Repo\" at \"https://dl.bintray.com/sfxcode/maven/\"\n\nlibraryDependencies += \"com.sfxcode.nosql\" %% \"simple-mongo\" % $app-version$","title":"Dependency Setup"},{"location":"/index.html#2-12-dependency","text":"sbt libraryDependencies += \"com.sfxcode.nosql\" %% \"simple-mongo\" % \"v1.5.1\" Maven <dependency>\n  <groupId>com.sfxcode.nosql</groupId>\n  <artifactId>simple-mongo_2.12</artifactId>\n  <version>v1.5.1</version>\n</dependency> Gradle dependencies {\n  compile group: 'com.sfxcode.nosql', name: 'simple-mongo_2.12', version: 'v1.5.1'\n}","title":"2.12 Dependency"},{"location":"/index.html#licence","text":"Apache 2","title":"Licence"},{"location":"/dao/mongo_dao.html","text":"","title":"MongoDAO"},{"location":"/dao/mongo_dao.html#mongodao","text":"","title":"MongoDAO"},{"location":"/dao/mongo_dao.html#info","text":"MongoDAO is the core of this framework. The DAO Pattern simplifies database usage.\nThe MongoDAO object holds a reference to a MongoCollection and adds functions for easy collection handling.","title":"Info"},{"location":"/dao/mongo_dao.html#features","text":"MongoDAO Base (Drop, Index, Count) MongoDAO CRUD (Create, Insert, Delete) MongoDAO Search (Search, Distinct, Aggregate)","title":"Features"},{"location":"/dao/mongo_dao.html#usage","text":"A MongoDatabase and a collection name is needed.","title":"Usage"},{"location":"/dao/mongo_dao.html#create-dao","text":"A Type Parameter is used for automatic Document to Class conversion (case classes needs to be registered).\nobject RestaurantDAO extends MongoDAO[Restaurant](database, \"restaurants\")","title":"Create DAO"},{"location":"/dao/mongo_dao.html#use-dao","text":"```scala\n```","title":"Use DAO"},{"location":"/dao/base.html","text":"","title":"MongoDAO - Base Functions"},{"location":"/dao/base.html#mongodao-base-functions","text":"","title":"MongoDAO - Base Functions"},{"location":"/dao/base.html#info","text":"Base Collection functions. All functions support synchronous result handling (add Result to function name, e.g. drop -> dropResult).","title":"Info"},{"location":"/dao/base.html#drop","text":"Drop Collection.\ndef drop(): Observable[Completed]","title":"Drop"},{"location":"/dao/base.html#count","text":"Count of collection with optional filter.\ndef count(filter: Bson = Document()): Observable[Long]","title":"Count"},{"location":"/dao/base.html#indexes","text":"def createIndex(key: Bson, options: IndexOptions = IndexOptions()): SingleObservable[String]\n\n// Simple Index creation\ndef createIndexForField(field: String, sortAscending: Boolean = true): SingleObservable[String]\n\ndef dropIndex(keys: Bson): SingleObservable[Completed]\n\n// Simple Index delete\ndef dropIndexForName(name: String): SingleObservable[Completed]","title":"Indexes"},{"location":"/dao/crud.html","text":"","title":"MongoDAO - CRUD Functions"},{"location":"/dao/crud.html#mongodao-crud-functions","text":"","title":"MongoDAO - CRUD Functions"},{"location":"/dao/crud.html#info","text":"CRUD Collection functions.","title":"Info"},{"location":"/dao/crud.html#create","text":"def insertOne(value: A): Observable[Completed]\n\ndef insertOne(value: A), options: InsertOneOptions: Observable[Completed]\n\ndef insertMany(values: Seq[A]): Observable[Completed]\n\ndef insertMany(values: Seq[A], options: InsertManyOptions): Observable[Completed]","title":"Create"},{"location":"/dao/crud.html#update","text":"def replaceOne(value: A): Observable[UpdateResult]\n\ndef replaceOne(value: A, options: ReplaceOptions): Observable[UpdateResult]","title":"Update"},{"location":"/dao/crud.html#delete","text":"def deleteOne(value: A): Observable[DeleteResult]\n\ndef deleteOne(filter: Bson): Observable[DeleteResult]\n\ndef deleteMany(filter: Bson): Observable[DeleteResult]\n\ndef deleteAll(): Observable[DeleteResult]","title":"Delete"},{"location":"/dao/search.html","text":"","title":"MongoDAO - Search Functions"},{"location":"/dao/search.html#mongodao-search-functions","text":"","title":"MongoDAO - Search Functions"},{"location":"/dao/search.html#info","text":"","title":"Info"},{"location":"/dao/search.html#demo","text":"","title":"Demo"},{"location":"/dao/search.html#setup-imports","text":"// Filter helper functions\nimport com.sfxcode.nosql.mongo.Filter._\n// sort helper functions\nimport com.sfxcode.nosql.mongo.Sort._\n// implicits like Document from Map ...\nimport com.sfxcode.nosql.mongo._","title":"Setup imports"},{"location":"/dao/search.html#execute-search","text":"val females = PersonDAO.find(Map(\"gender\" -> \"female\"), \n    sortByKey(\"name\")).resultList()","title":"Execute Search"},{"location":"/dao/gridfs_dao.html","text":"","title":"GridFSDAO"},{"location":"/dao/gridfs_dao.html#gridfsdao","text":"","title":"GridFSDAO"},{"location":"/dao/gridfs_dao.html#info","text":"GridFSDAO adds MongoDB GridFS support. It provides easy upload, download and metadata handling.\nSometimes also normal collections can be helpful for storing data.\nOfficial_MongoDB_Documentation Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.Furthermore, if your files are all smaller than the 16 MB BSON Document Size limit, consider storing each file in a single document instead of using GridFS. You may use the BinData data type to store the binary data. See your drivers documentation for details on using BinData.","title":"Info"},{"location":"/dao/gridfs_dao.html#usage","text":"A MongoDatabase and a bucket name is needed.","title":"Usage"},{"location":"/dao/gridfs_dao.html#create-dao","text":"/**\n  * use bucket name fs\n  */\n  object ImageFilesDAO extends GridFSDAO(database)\n\n  /**\n  * use bucket name images\n  */\n  object ImageFilesDAO extends GridFSDAO(database, \"images\")","title":"Create DAO"},{"location":"/gridfs/crud.html","text":"","title":"GridFSDAO - CRUD Functions"},{"location":"/gridfs/crud.html#gridfsdao-crud-functions","text":"","title":"GridFSDAO - CRUD Functions"},{"location":"/gridfs/crud.html#create","text":"You need a fiename, an input stream and some kind of meatadata.\nPossible Metadata types: * Document * Map * Scala Case Class\nReturn Observable of ObjectId.\nImageFilesDAO.insertOne(filename, stream, metadata)","title":"Create"},{"location":"/gridfs/crud.html#update","text":"Official_MongoDB_Documentation Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.Do not use GridFS if you need to update the content of the entire file atomically. As an alternative you can store multiple versions of each file and specify the current version of the file in the metadata. You can update the metadata field that indicates “latest” status in an atomic update after uploading the new version of the file, and later remove previous versions if needed.","title":"Update"},{"location":"/gridfs/crud.html#delete","text":"GridFSFile will be deleted by a given ObjectID.\nWith implicit conversion you can use for oid Parameter: * ObjectID * GridFSFile * String\n// for implicit conversion usage\n  import com.sfxcode.nosql.mongo._\n  \n  ImageFilesDAO.deleteOne(oid)","title":"Delete"},{"location":"/features/aggregation.html","text":"","title":"Feature - Aggregation"},{"location":"/features/aggregation.html#feature-aggregation","text":"","title":"Feature - Aggregation"},{"location":"/features/aggregation.html#info","text":"MongoDB support an easy to use Aggregation Handling.","title":"Info"},{"location":"/features/aggregation.html#demo","text":"","title":"Demo"},{"location":"/features/aggregation.html#setup-imports","text":"import com.sfxcode.nosql.mongo.Field._\nimport com.sfxcode.nosql.mongo.Filter._\nimport com.sfxcode.nosql.mongo.Sort._\nimport com.sfxcode.nosql.mongo._\nFull source at GitHub","title":"Setup imports"},{"location":"/features/aggregation.html#define-stages","text":"val filterStage: Bson = filter(and(\n  equal(\"gender\", \"female\"),\n  notNullFilter(\"balance\")))\n\nval groupStage: Bson = group(\n  Map(\"age\" -> \"$age\"),\n  sumField(\"balance\"), firstField(\"age\"))\n\nval sortStage: Bson = sort(sortByKey(\"age\"))\nFull source at GitHub","title":"Define stages"},{"location":"/features/aggregation.html#execute-aggregation","text":"Important In most cases we have to use the RAW attribute, because the aggregation result not follows the case class pattern. RAW returns always Documents instead of case classes.\nval aggregator = List(filterStage, groupStage, sortStage)\n\nval aggregated = PersonDAO.Raw.findAggregated(aggregator).resultList()\nFull source at GitHub","title":"Execute Aggregation"},{"location":"/features/aggregation.html#convert-result","text":"For easy result handling, using the implicit Document to Map conversion can be useful.\nval list: List[Map[String, Any]] = aggregated\nFull source at GitHub","title":"Convert Result"},{"location":"/features/relationships.html","text":"","title":"Feature - Relationships"},{"location":"/features/relationships.html#feature-relationships","text":"","title":"Feature - Relationships"},{"location":"/features/relationships.html#info","text":"Normal Relationship handling is the use of embedded documents. However, sometimes there is a need for relationsips beetween collections. There is a Relations Trait to be used in case classes for easy relationship handling.","title":"Info"},{"location":"/features/relationships.html#relations-trait","text":"The Relations trait extends DAO case classes with relationship functions.\nrelatedRecordForOneToOne (OneToOneRelationship and reference vlue needed) relatedRecordsForOneToMany (OneToManyRelationship and reference vlue needed)","title":"Relations trait"},{"location":"/features/relationships.html#demo","text":"Simple Setup.\nUser Collection(should have one login and multiple friends) Login Collection Friend Collection\ncase class User(id: Long, name: String, loginId: String)\n  case class Login(id: String, email: String, password: String)\n  case class Friend(id: Long, name: String, userId: Long)\n  \n  object UserDAO extends MongoDAO[User](database, \"user\") \n  object LoginDAO extends MongoDAO[Login](database, \"login\")\n  object FriendDAO extends MongoDAO[Friend](database, \"friend\")\nFor relationship setup we create two Relationships in the UserDAO.\nOneToOne loginRelation (LoginDAO, key is id in user collection) OneToMany friendsRelation (FriendDAO, key is userId in friend collection)\nobject UserDAO extends MongoDAO[User](database, \"user\") {\n  lazy val loginRelation = OneToOneRelationship(LoginDAO, \"id\")\n  lazy val friendsRelation = OneToManyRelationship(FriendDAO, \"userId\")\n}\nFull source at GitHub\nWe extend the User case class with the Relations trait and add relation specific functions.\nlogin (create an Option of Login) friends (create a List of Friend)\ncase class User(id: Long, name: String, loginId: String) extends Relations {\n\n  def login: Option[Login] = relatedRecordForOneToOne(UserDAO.loginRelation, loginId)\n\n  def friends: List[Friend] = relatedRecordForOneToMany(UserDAO.friendsRelation, id)\n\n}\nFull source at GitHub","title":"Demo"},{"location":"/features/observable.html","text":"","title":"Feature - Observable"},{"location":"/features/observable.html#feature-observable","text":"","title":"Feature - Observable"},{"location":"/features/observable.html#info","text":"MongoDB_Scala_Driver_Documentation The MongoDB Scala Driver is an asynchronous and non blocking driver. Using the Observable model asynchronous events become simple, composable operations, freed from the complexity of nested callbacks.\nSee MongoDB Scala Driver Documentation.","title":"Info"},{"location":"/features/observable.html#dealing-with-observables","text":"","title":"Dealing with Observables"},{"location":"/features/observable.html#as-future","text":"def findAllRestaurants: Future[Seq[Restaurant]] = \n      RestaurantDAO.find().asFuture()","title":"As Future"},{"location":"/features/observable.html#result-functions","text":"Convert Observable to result object. Import mongo package is needed.\nFunctions headResult anf resultList have an optional maxWait in seconds parameter (Default maxWait = 10 seconds).\nimport com.sfxcode.nosql.mongo._\n\n  def restaurantsSize = RestaurantDAO.count().headResult()\n  \n  def findAllRestaurants = RestaurantDAO.find().resultList(maxWait = 20)","title":"Result Functions"},{"location":"/features/observable.html#implicit-result-functions","text":"Implicit result conversion to a given type. Import mongo package is needed.\nimport com.sfxcode.nosql.mongo._\n\n  def restaurantsSize: Long = RestaurantDAO.count()\n  \n  def findAllRestaurants:List[Restaurant] = RestaurantDAO.find()","title":"Implicit Result Functions"},{"location":"/tutorial/setup.html","text":"","title":"Tutorial Part 1 - Setup"},{"location":"/tutorial/setup.html#tutorial-part-1-setup","text":"","title":"Tutorial Part 1 - Setup"},{"location":"/tutorial/setup.html#mongodb-demo-database","text":"","title":"MongoDB Demo Database"},{"location":"/tutorial/setup.html#setup","text":"Use Import from MongoDB Website:\nRestaurant Data Import","title":"Setup"},{"location":"/tutorial/setup.html#sample-document","text":"A sample document in the restaurants collection:\n{\n  \"address\": {\n     \"building\": \"1007\",\n     \"coord\": [ -73.856077, 40.848447 ],\n     \"street\": \"Morris Park Ave\",\n     \"zipcode\": \"10462\"\n  },\n  \"borough\": \"Bronx\",\n  \"cuisine\": \"Bakery\",\n  \"grades\": [\n     { \"date\": { \"$date\": 1393804800000 }, \"grade\": \"A\", \"score\": 2 },\n     { \"date\": { \"$date\": 1378857600000 }, \"grade\": \"A\", \"score\": 6 },\n     { \"date\": { \"$date\": 1358985600000 }, \"grade\": \"A\", \"score\": 10 },\n     { \"date\": { \"$date\": 1322006400000 }, \"grade\": \"A\", \"score\": 9 },\n     { \"date\": { \"$date\": 1299715200000 }, \"grade\": \"B\", \"score\": 14 }\n  ],\n  \"name\": \"Morris Park Bake Shop\",\n  \"restaurant_id\": \"30075445\"\n}","title":"Sample Document"},{"location":"/tutorial/setup.html#scala-case-classes-for-restaurant-document","text":"case class Address(street: String, building: String,\n  zipcode: String, coord: List[Double])\n\ncase class Grade(date: Date, grade: String, score: Int)\n\ncase class Restaurant(restaurant_id: String, name: String,\n  borough: String, cuisine: String,\n  grades: List[Grade], address: Address,\n  _id: ObjectId = new ObjectId())\nFull source at GitHub","title":"Scala case classes for Restaurant document"},{"location":"/tutorial/database.html","text":"","title":"Tutorial Part 2 - Database"},{"location":"/tutorial/database.html#tutorial-part-2-database","text":"","title":"Tutorial Part 2 - Database"},{"location":"/tutorial/database.html#info","text":"The database provides static import to our DAO objects.","title":"Info"},{"location":"/tutorial/database.html#imports","text":"import java.util.Date\n\nimport com.sfxcode.nosql.mongo.MongoDAO\nimport com.sfxcode.nosql.mongo.database.DatabaseProvider\nimport org.bson.codecs.configuration.CodecRegistries._\nimport org.mongodb.scala.bson.ObjectId\nimport org.mongodb.scala.bson.codecs.Macros._\nFull source at GitHub","title":"Imports"},{"location":"/tutorial/database.html#case-classes-for-document-representation","text":"case class Address(street: String, building: String,\n  zipcode: String, coord: List[Double])\n\ncase class Grade(date: Date, grade: String, score: Int)\n\ncase class Restaurant(restaurant_id: String, name: String,\n  borough: String, cuisine: String,\n  grades: List[Grade], address: Address,\n  _id: ObjectId = new ObjectId())\nFull source at GitHub","title":"case classes for document representation"},{"location":"/tutorial/database.html#registry-and-database","text":"scala-mongo-driver use a registry pattern for deserialization\nprivate val registry = fromProviders(\n  classOf[Restaurant],\n  classOf[Address], classOf[Grade])\n\nval database = DatabaseProvider(\"test\", registry)\nFull source at GitHub","title":"Registry and database"},{"location":"/tutorial/database.html#restaurant-dao","text":"object RestaurantDAO extends MongoDAO[Restaurant](database, \"restaurants\")\nFull source at GitHub","title":"Restaurant DAO"},{"location":"/tutorial/database.html#usage","text":"Create Database object\nobject RestaurantDatabase {\n\n// case classes ...\n\n// registry and database setup ...\n\nobject RestaurantDAO extends MongoDAO[Restaurant](database, \"restaurants\")\n\n// more DAO objects\n}\nStatic Import and Application\n// static import of needed DAO objects\n   import my.namespace.RestaurantDatabase._\n   \n   // ... some code","title":"Usage"},{"location":"/tutorial/functions.html","text":"","title":"Tutorial Part 3 - Functions"},{"location":"/tutorial/functions.html#tutorial-part-3-functions","text":"","title":"Tutorial Part 3 - Functions"},{"location":"/tutorial/functions.html#info","text":"Use a functions trait to define some commonly used funtions.","title":"Info"},{"location":"/tutorial/functions.html#imports","text":"// static import of needed DAO objects\nimport com.sfxcode.nosql.mongo.demo.restaurant.RestaurantDemoDatabase._\n\n// static import of mongo package object for needed implicits\nimport com.sfxcode.nosql.mongo._\nFull source at GitHub","title":"Imports"},{"location":"/tutorial/functions.html#simple-application","text":"/**\n * single result with implicit conversion to Entity Option\n */\ndef findRestaurantByName(name: String): Option[Restaurant] =\n  RestaurantDAO.find(\"name\", name)\n\ndef restaurantsSize: Long = RestaurantDAO.count()\n\n/**\n * result with implicit conversion to List of Entities\n */\ndef findAllRestaurants(filterValues: Map[String, Any] = Map()): List[Restaurant] =\n  RestaurantDAO.find(filterValues)\nFull source at GitHub","title":"Simple Application"},{"location":"/tutorial/application.html","text":"","title":"Tutorial Part 4 - Application"},{"location":"/tutorial/application.html#tutorial-part-4-application","text":"","title":"Tutorial Part 4 - Application"},{"location":"/tutorial/application.html#info","text":"This Demo Application should demonstrate the basic usage of simple-mongo.","title":"Info"},{"location":"/tutorial/application.html#simple-application","text":"object RestaurantDemoApp extends App with RestaurantDemoDatabaseFunctions {\n\n  // find specific restaurant by name as Option Result\n  val restaurant = findRestaurantByName(\"Dj Reynolds Pub And Restaurant\")\n\n  println(restaurant)\n\n  // use count function\n  println(restaurantsSize)\n\n  // find restaurants by filter\n  private val filter = Map(\"address.zipcode\" -> \"10075\", \"cuisine\" -> \"Italian\")\n  val restaurants = findAllRestaurants(filter)\n\n  restaurants.sortBy(r => r.name).foreach(r => println(r.name))\n\n}\nFull source at GitHub","title":"Simple Application"},{"location":"/changes.html","text":"","title":"Version History"},{"location":"/changes.html#version-history","text":"","title":"Version History"},{"location":"/changes.html#current-version","text":"","title":"Current Version"},{"location":"/changes.html#history","text":"# Changes #\n\n## Versions\n\n### 1.5.1\n\n* DatabaseProvider refactored\n* ObservableImplicits to package object added\n* update docs for Observable\n\n### 1.5.0\n* GridFSSupport\n\n\n### 1.4.0\n*  dropped operations with pattern <name>Result (use headResult, list result or implicit conversion instead)\n*  introduce Database Functions trait\n*  update docs\n\n\n### 1.3.1\n* update mongo-scala-driver to 2.4.0\n* Operations Base count method support CountOptions\n\n\n### 1.3.0\n\n* Crud refactoring\n* CrudObserver Trait (optional usage)\n\n\n### 1.2.0\n\n* Relations added\n* Field added (used in Aggregation)\n* Aggregation Specs added\n* implicit Document(s) to Map(s) Conversion\n* method sort in Sort object renamed to sortByKey\n\n### 1.1.0\n\n* update mongo-scala-driver to 2.3.0\n* update to Scala 2.12.6\n\n### 1.0.5\n\n* update to Scala 2.12.5\n\n### 1.0.4\n\n* update to mongo scala driver 2.2.1\n\n### 1.0.3\n\n* gh-pages added\n* test fixes\n\n### 1.0.2\n\n* update to mongo scala driver 2.2.0\n\n### 1.0.1\n\n* BuildInfo added\n* dependencies updated\n* plugins updated\n* Index support addded\nFull source at GitHub","title":"History"},{"location":"/features/converter.html","text":"","title":"Feature - BSON Converter"},{"location":"/features/converter.html#feature-bson-converter","text":"","title":"Feature - BSON Converter"},{"location":"/features/converter.html#info","text":"","title":"Info"}]}